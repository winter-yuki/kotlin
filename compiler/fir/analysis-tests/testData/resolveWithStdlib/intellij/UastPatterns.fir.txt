FILE: UastPatterns.kt
    public abstract interface UElement : R|kotlin/Any| {
    }
    public abstract interface UExpression : R|UElement| {
    }
    public abstract interface UReferenceExpression : R|UExpression| {
    }
    public final fun injectionHostOrReferenceExpression(): R|UExpressionPattern.Capture<UExpression>| {
        ^injectionHostOrReferenceExpression R|/uExpression|().R|SubstitutionOverride</UExpressionPattern.Capture.filter: R|UExpressionPattern.Capture<UExpression>|>|(<L> = filter@fun <anonymous>(it: R|UExpression|): R|kotlin/Boolean| <inline=NoInline>  {
            ^ (R|<local>/it| is R|UReferenceExpression|)
        }
        )
    }
    public final fun uExpression(): R|UExpressionPattern.Capture<UExpression>| {
        ^uExpression R|/expressionCapture|<R|UExpression|>(<getClass>(Q|UExpression|).R|kotlin/jvm/java|<R|UExpression|>)
    }
    public final fun <T : R|UExpression|> expressionCapture(clazz: R|java/lang/Class<T>|): R|UExpressionPattern.Capture<T>| {
        ^expressionCapture Q|UExpressionPattern|.R|SubstitutionOverride</UExpressionPattern.Capture.Capture>|<R|T|>(R|<local>/clazz|)
    }
    public open class UElementPattern<T : R|UElement|, Self1 : R|UElementPattern<T, Self1>|> : R|ObjectPattern<T, Self1>| {
        public constructor<T : R|UElement|, Self1 : R|UElementPattern<T, Self1>|>(clazz: R|java/lang/Class<T>|): R|UElementPattern<T, Self1>| {
            super<R|ObjectPattern<T, Self1>|>(R|<local>/clazz|)
        }

        public final fun filter(filter: R|(T) -> kotlin/Boolean|): R|Self1| {
            ^filter (this@R|/UElementPattern| as R|Self1|)
        }

    }
    public open class UExpressionPattern<T : R|UExpression|, Self1 : R|UExpressionPattern<T, Self1>|> : R|UElementPattern<T, Self1>| {
        public constructor<T : R|UExpression|, Self1 : R|UExpressionPattern<T, Self1>|>(clazz: R|java/lang/Class<T>|): R|UExpressionPattern<T, Self1>| {
            super<R|UElementPattern<T, Self1>|>(R|<local>/clazz|)
        }

        public open class Capture<T : R|UExpression|> : R|UExpressionPattern<T, UExpressionPattern.Capture<T>>| {
            public constructor<T : R|UExpression|>(clazz: R|java/lang/Class<T>|): R|UExpressionPattern.Capture<T>| {
                super<R|UExpressionPattern<T, UExpressionPattern.Capture<T>>|>(R|<local>/clazz|)
            }

        }

    }
